<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffeine Core: Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffeine Core
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocatorInterface__s.html">AllocatorInterface_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an interface to standardize custom allocators implementation.  <a href="structAllocatorInterface__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga445f854a7fb44af7fd6911674d5aaf03"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structAllocatorInterface__s.html">AllocatorInterface_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a></td></tr>
<tr class="memdesc:ga445f854a7fb44af7fd6911674d5aaf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A syntax sugar for struct <a class="el" href="structAllocatorInterface__s.html" title="Defines an interface to standardize custom allocators implementation.">AllocatorInterface_s</a>.  <a href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">More...</a><br /></td></tr>
<tr class="separator:ga445f854a7fb44af7fd6911674d5aaf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaccf8c924a13e92120e947e5914fd579"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaaccf8c924a13e92120e947e5914fd579">cff_allocator_alloc</a> (<a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *allocator, size_t size)</td></tr>
<tr class="memdesc:gaaccf8c924a13e92120e947e5914fd579"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to allocate memory using an AllocatorInterface.  <a href="group__Memory.html#gaaccf8c924a13e92120e947e5914fd579">More...</a><br /></td></tr>
<tr class="separator:gaaccf8c924a13e92120e947e5914fd579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0579d7e1221998f9aa469414b02135"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga2c0579d7e1221998f9aa469414b02135">cff_allocator_realloc</a> (<a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *allocator, void *ptr, size_t size, void **out)</td></tr>
<tr class="memdesc:ga2c0579d7e1221998f9aa469414b02135"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to reallocate memory using an AllocatorInterface.  <a href="group__Memory.html#ga2c0579d7e1221998f9aa469414b02135">More...</a><br /></td></tr>
<tr class="separator:ga2c0579d7e1221998f9aa469414b02135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979ab4ea6acac240194b25800bfd3ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga979ab4ea6acac240194b25800bfd3ebb">cff_allocator_free</a> (<a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *allocator, void *ptr)</td></tr>
<tr class="memdesc:ga979ab4ea6acac240194b25800bfd3ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to deallocate memory using an AllocatorInterface.  <a href="group__Memory.html#ga979ab4ea6acac240194b25800bfd3ebb">More...</a><br /></td></tr>
<tr class="separator:ga979ab4ea6acac240194b25800bfd3ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f19c0d35c8fe341e799ad5b98512cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga61f19c0d35c8fe341e799ad5b98512cd">cff_allocator_mem_size</a> (<a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *allocator, void *ptr)</td></tr>
<tr class="memdesc:ga61f19c0d35c8fe341e799ad5b98512cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that gets the size of an allocated block.  <a href="group__Memory.html#ga61f19c0d35c8fe341e799ad5b98512cd">More...</a><br /></td></tr>
<tr class="separator:ga61f19c0d35c8fe341e799ad5b98512cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e877bdff45190aae9631afc417aa770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga7e877bdff45190aae9631afc417aa770">cff_get_default_allocator</a> ()</td></tr>
<tr class="memdesc:ga7e877bdff45190aae9631afc417aa770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that provides a pointer to the default memory allocator in the process.  <a href="group__Memory.html#ga7e877bdff45190aae9631afc417aa770">More...</a><br /></td></tr>
<tr class="separator:ga7e877bdff45190aae9631afc417aa770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6df5a128cc2f599951fadf5c488d92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gae6df5a128cc2f599951fadf5c488d92a">cff_set_default_allocator</a> (<a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *allocator)</td></tr>
<tr class="memdesc:gae6df5a128cc2f599951fadf5c488d92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that provides a pointer to the default memory allocator in the process.  <a href="group__Memory.html#gae6df5a128cc2f599951fadf5c488d92a">More...</a><br /></td></tr>
<tr class="separator:gae6df5a128cc2f599951fadf5c488d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c01abf99f1adb5c8d9c0aab4993ae40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga5c01abf99f1adb5c8d9c0aab4993ae40">cff_heap_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga5c01abf99f1adb5c8d9c0aab4993ae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory block using the libc malloc function.  <a href="group__Memory.html#ga5c01abf99f1adb5c8d9c0aab4993ae40">More...</a><br /></td></tr>
<tr class="separator:ga5c01abf99f1adb5c8d9c0aab4993ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aada1415e48822c27fbe4301466386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga49aada1415e48822c27fbe4301466386">cff_heap_realloc</a> (void *ptr, size_t size, void **out)</td></tr>
<tr class="memdesc:ga49aada1415e48822c27fbe4301466386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a memory block using the libc realloc function.  <a href="group__Memory.html#ga49aada1415e48822c27fbe4301466386">More...</a><br /></td></tr>
<tr class="separator:ga49aada1415e48822c27fbe4301466386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b117b042990752ddc6b92a6de2e946b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga6b117b042990752ddc6b92a6de2e946b">cff_heap_alloc_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga6b117b042990752ddc6b92a6de2e946b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a memory block using the libc free function.  <a href="group__Memory.html#ga6b117b042990752ddc6b92a6de2e946b">More...</a><br /></td></tr>
<tr class="separator:ga6b117b042990752ddc6b92a6de2e946b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0108b146a32a216acc45e67da082452"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gab0108b146a32a216acc45e67da082452">cff_stack_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:gab0108b146a32a216acc45e67da082452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory block on stack.  <a href="group__Memory.html#gab0108b146a32a216acc45e67da082452">More...</a><br /></td></tr>
<tr class="separator:gab0108b146a32a216acc45e67da082452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49b63a4451c349ef8f63b8a86410990"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaf49b63a4451c349ef8f63b8a86410990">cff_stack_realloc</a> (void *ptr, size_t old_size, size_t size, void **out)</td></tr>
<tr class="memdesc:gaf49b63a4451c349ef8f63b8a86410990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a memory block on stack.  <a href="group__Memory.html#gaf49b63a4451c349ef8f63b8a86410990">More...</a><br /></td></tr>
<tr class="separator:gaf49b63a4451c349ef8f63b8a86410990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061df742a844aa0bbb3487f4962705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga3a061df742a844aa0bbb3487f4962705">cff_stack_alloc_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga3a061df742a844aa0bbb3487f4962705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a memory block on stack.  <a href="group__Memory.html#ga3a061df742a844aa0bbb3487f4962705">More...</a><br /></td></tr>
<tr class="separator:ga3a061df742a844aa0bbb3487f4962705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9ab770651d550cd2548265ece17cf2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga6b9ab770651d550cd2548265ece17cf2">cff_mem_size</a> (void *ptr)</td></tr>
<tr class="memdesc:ga6b9ab770651d550cd2548265ece17cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that gets the size of an allocated block.  <a href="group__Memory.html#ga6b9ab770651d550cd2548265ece17cf2">More...</a><br /></td></tr>
<tr class="separator:ga6b9ab770651d550cd2548265ece17cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9d9280f86864f85ec68406a5e9b9e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga9e9d9280f86864f85ec68406a5e9b9e8">cff_memcmp</a> (const void *a, const void *b, size_t size)</td></tr>
<tr class="memdesc:ga9e9d9280f86864f85ec68406a5e9b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a sequence of bytes from two adress have the same value.  <a href="group__Memory.html#ga9e9d9280f86864f85ec68406a5e9b9e8">More...</a><br /></td></tr>
<tr class="separator:ga9e9d9280f86864f85ec68406a5e9b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3a3426c9610dfd1397d12838560f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga6e3a3426c9610dfd1397d12838560f07">cff_memcpy</a> (const void *const src, void *const dest, size_t src_size, size_t dest_size)</td></tr>
<tr class="memdesc:ga6e3a3426c9610dfd1397d12838560f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence of bytes from src to dest.  <a href="group__Memory.html#ga6e3a3426c9610dfd1397d12838560f07">More...</a><br /></td></tr>
<tr class="separator:ga6e3a3426c9610dfd1397d12838560f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a6a44fbe82e8a94581c78788117237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gad6a6a44fbe82e8a94581c78788117237">cff_memmove</a> (const void *const src, void *const dest, size_t src_size, size_t dest_size)</td></tr>
<tr class="memdesc:gad6a6a44fbe82e8a94581c78788117237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a sequence of bytes from src to dest.  <a href="group__Memory.html#gad6a6a44fbe82e8a94581c78788117237">More...</a><br /></td></tr>
<tr class="separator:gad6a6a44fbe82e8a94581c78788117237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd76bcd3d6736ee62e1c24f020426b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gabd76bcd3d6736ee62e1c24f020426b26">cff_memset</a> (void *dest, int value, size_t size)</td></tr>
<tr class="memdesc:gabd76bcd3d6736ee62e1c24f020426b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of an memory block to a value.  <a href="group__Memory.html#gabd76bcd3d6736ee62e1c24f020426b26">More...</a><br /></td></tr>
<tr class="separator:gabd76bcd3d6736ee62e1c24f020426b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218e303b8bc16cb29424a87793eac95c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga218e303b8bc16cb29424a87793eac95c">cff_memcmp_8</a> (const void *const a, const void *const b, size_t size)</td></tr>
<tr class="memdesc:ga218e303b8bc16cb29424a87793eac95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a sequence of bytes from two adress have the same value 8 bits at a time.  <a href="group__Memory.html#ga218e303b8bc16cb29424a87793eac95c">More...</a><br /></td></tr>
<tr class="separator:ga218e303b8bc16cb29424a87793eac95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2961128d7e32b4be2947c8e5c699ba6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga2961128d7e32b4be2947c8e5c699ba6b">cff_memcmp_16</a> (const void *const a, const void *const b, size_t size)</td></tr>
<tr class="memdesc:ga2961128d7e32b4be2947c8e5c699ba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a sequence of bytes from two adress have the same value 16 bits at a time.  <a href="group__Memory.html#ga2961128d7e32b4be2947c8e5c699ba6b">More...</a><br /></td></tr>
<tr class="separator:ga2961128d7e32b4be2947c8e5c699ba6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe32578a5c13aae86c1343bfee710b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaefe32578a5c13aae86c1343bfee710b9">cff_memcmp_32</a> (const void *const a, const void *const b, size_t size)</td></tr>
<tr class="memdesc:gaefe32578a5c13aae86c1343bfee710b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a sequence of bytes from two adress have the same value 32 bits at a time.  <a href="group__Memory.html#gaefe32578a5c13aae86c1343bfee710b9">More...</a><br /></td></tr>
<tr class="separator:gaefe32578a5c13aae86c1343bfee710b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b05c6c11bba139ee2f70420f8957cc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga0b05c6c11bba139ee2f70420f8957cc1">cff_memcmp_64</a> (const void *const a, const void *const b, size_t size)</td></tr>
<tr class="memdesc:ga0b05c6c11bba139ee2f70420f8957cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a sequence of bytes from two adress have the same value 64 bits at a time.  <a href="group__Memory.html#ga0b05c6c11bba139ee2f70420f8957cc1">More...</a><br /></td></tr>
<tr class="separator:ga0b05c6c11bba139ee2f70420f8957cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de69c3a155909468ef291bdc829dc6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga1de69c3a155909468ef291bdc829dc6e">cff_memcpy_8</a> (const void *const src, void *const dest, size_t size)</td></tr>
<tr class="memdesc:ga1de69c3a155909468ef291bdc829dc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence of bytes from src to dest 8 bits at a time.  <a href="group__Memory.html#ga1de69c3a155909468ef291bdc829dc6e">More...</a><br /></td></tr>
<tr class="separator:ga1de69c3a155909468ef291bdc829dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad468d324fac5c33fb8face5a53077e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gad468d324fac5c33fb8face5a53077e7d">cff_memcpy_16</a> (const void *const src, void *const dest, size_t size)</td></tr>
<tr class="memdesc:gad468d324fac5c33fb8face5a53077e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence of bytes from src to dest 16 bits at a time.  <a href="group__Memory.html#gad468d324fac5c33fb8face5a53077e7d">More...</a><br /></td></tr>
<tr class="separator:gad468d324fac5c33fb8face5a53077e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee1f881d66530582a85576f574c20b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaaee1f881d66530582a85576f574c20b5">cff_memcpy_32</a> (const void *const src, void *const dest, size_t size)</td></tr>
<tr class="memdesc:gaaee1f881d66530582a85576f574c20b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence of bytes from src to dest 32 bits at a time.  <a href="group__Memory.html#gaaee1f881d66530582a85576f574c20b5">More...</a><br /></td></tr>
<tr class="separator:gaaee1f881d66530582a85576f574c20b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3388ff2de7f5be41ba8f16b50fa32ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga3388ff2de7f5be41ba8f16b50fa32ae7">cff_memcpy_64</a> (const void *const src, void *const dest, size_t size)</td></tr>
<tr class="memdesc:ga3388ff2de7f5be41ba8f16b50fa32ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sequence of bytes from src to dest 64 bits at a time.  <a href="group__Memory.html#ga3388ff2de7f5be41ba8f16b50fa32ae7">More...</a><br /></td></tr>
<tr class="separator:ga3388ff2de7f5be41ba8f16b50fa32ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2435b5ed5edcc3625a0ec8305c21b759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga2435b5ed5edcc3625a0ec8305c21b759">cff_memset_8</a> (void *const dest, char value, size_t size)</td></tr>
<tr class="memdesc:ga2435b5ed5edcc3625a0ec8305c21b759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of an memory block to a value 8 bits at a time.  <a href="group__Memory.html#ga2435b5ed5edcc3625a0ec8305c21b759">More...</a><br /></td></tr>
<tr class="separator:ga2435b5ed5edcc3625a0ec8305c21b759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17df1fd696d59eef769f7bb2d33cc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaa17df1fd696d59eef769f7bb2d33cc9a">cff_memset_16</a> (void *const dest, short value, size_t size)</td></tr>
<tr class="memdesc:gaa17df1fd696d59eef769f7bb2d33cc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of an memory block to a value 16 bits at a time.  <a href="group__Memory.html#gaa17df1fd696d59eef769f7bb2d33cc9a">More...</a><br /></td></tr>
<tr class="separator:gaa17df1fd696d59eef769f7bb2d33cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf67e79f9c78ca3fc8463712522d20f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gadf67e79f9c78ca3fc8463712522d20f4">cff_memset_32</a> (void *const dest, int value, size_t size)</td></tr>
<tr class="memdesc:gadf67e79f9c78ca3fc8463712522d20f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of an memory block to a value 32 bits at a time.  <a href="group__Memory.html#gadf67e79f9c78ca3fc8463712522d20f4">More...</a><br /></td></tr>
<tr class="separator:gadf67e79f9c78ca3fc8463712522d20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20903b42f22118605a60452eb93df5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gab20903b42f22118605a60452eb93df5f">cff_memset_64</a> (void *const dest, long long int value, size_t size)</td></tr>
<tr class="memdesc:gab20903b42f22118605a60452eb93df5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of an memory block to a value 64 bits at a time.  <a href="group__Memory.html#gab20903b42f22118605a60452eb93df5f">More...</a><br /></td></tr>
<tr class="separator:gab20903b42f22118605a60452eb93df5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga445f854a7fb44af7fd6911674d5aaf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga445f854a7fb44af7fd6911674d5aaf03">&#9670;&nbsp;</a></span>AllocatorInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structAllocatorInterface__s.html">AllocatorInterface_s</a> <a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A syntax sugar for struct <a class="el" href="structAllocatorInterface__s.html" title="Defines an interface to standardize custom allocators implementation.">AllocatorInterface_s</a>. </p>
<p>Defines an interface to standardize custom allocators implementation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaccf8c924a13e92120e947e5914fd579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccf8c924a13e92120e947e5914fd579">&#9670;&nbsp;</a></span>cff_allocator_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * cff_allocator_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to allocate memory using an AllocatorInterface. </p>
<p>This funcion calls the allocator alloc function passing the necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>pointer to an AllocatorInterface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of memory block to be allocated in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory block or null in failure cases. </dd></dl>

</div>
</div>
<a id="ga979ab4ea6acac240194b25800bfd3ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979ab4ea6acac240194b25800bfd3ebb">&#9670;&nbsp;</a></span>cff_allocator_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_allocator_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to deallocate memory using an AllocatorInterface. </p>
<p>This funcion calls the allocator dealloc function passing the necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>pointer to an AllocatorInterface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61f19c0d35c8fe341e799ad5b98512cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f19c0d35c8fe341e799ad5b98512cd">&#9670;&nbsp;</a></span>cff_allocator_mem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cff_allocator_mem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that gets the size of an allocated block. </p>
<p>This funcion calls the allocator get_size function passing the necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>pointer to an AllocatorInterface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the block in bytes. </dd></dl>

</div>
</div>
<a id="ga2c0579d7e1221998f9aa469414b02135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c0579d7e1221998f9aa469414b02135">&#9670;&nbsp;</a></span>cff_allocator_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cff_allocator_realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to reallocate memory using an AllocatorInterface. </p>
<p>This funcion calls the allocator realloc function passing the necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>pointer to an AllocatorInterface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be reallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the new size for the memory block in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>pointer to the memory block after reallocated or to null in failure case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in failure case or 1 in sucess case. </dd></dl>

</div>
</div>
<a id="ga7e877bdff45190aae9631afc417aa770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e877bdff45190aae9631afc417aa770">&#9670;&nbsp;</a></span>cff_get_default_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> * cff_get_default_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that provides a pointer to the default memory allocator in the process. </p>
<p>By default this function will return a pointer to an allocator interface that uses the functions provided by the libc (eg. malloc, realloc and free). The default allocator can be changed using the </p>

</div>
</div>
<a id="ga5c01abf99f1adb5c8d9c0aab4993ae40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c01abf99f1adb5c8d9c0aab4993ae40">&#9670;&nbsp;</a></span>cff_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * cff_heap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory block using the libc malloc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of block to be allocated in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory block or null in failure cases.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="ga6b117b042990752ddc6b92a6de2e946b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b117b042990752ddc6b92a6de2e946b">&#9670;&nbsp;</a></span>cff_heap_alloc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_heap_alloc_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a memory block using the libc free function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be deallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="ga49aada1415e48822c27fbe4301466386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49aada1415e48822c27fbe4301466386">&#9670;&nbsp;</a></span>cff_heap_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cff_heap_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates a memory block using the libc realloc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be reallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the new size for the memory block in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>pointer to the memory block after reallocated or to null in failure case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in failure case or 1 in sucess case.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="ga6b9ab770651d550cd2548265ece17cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9ab770651d550cd2548265ece17cf2">&#9670;&nbsp;</a></span>cff_mem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cff_mem_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that gets the size of an allocated block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the block in bytes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="ga9e9d9280f86864f85ec68406a5e9b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e9d9280f86864f85ec68406a5e9b9e8">&#9670;&nbsp;</a></span>cff_memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a sequence of bytes from two adress have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to an adress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>pointer to an adress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of sequence to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if are equals and 0 if not. </dd></dl>

</div>
</div>
<a id="ga2961128d7e32b4be2947c8e5c699ba6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2961128d7e32b4be2947c8e5c699ba6b">&#9670;&nbsp;</a></span>cff_memcmp_16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_memcmp_16 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a sequence of bytes from two adress have the same value 16 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of sequence to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if are equals and 0 if not. </dd></dl>

</div>
</div>
<a id="gaefe32578a5c13aae86c1343bfee710b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefe32578a5c13aae86c1343bfee710b9">&#9670;&nbsp;</a></span>cff_memcmp_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_memcmp_32 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a sequence of bytes from two adress have the same value 32 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of sequence to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if are equals and 0 if not. </dd></dl>

</div>
</div>
<a id="ga0b05c6c11bba139ee2f70420f8957cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b05c6c11bba139ee2f70420f8957cc1">&#9670;&nbsp;</a></span>cff_memcmp_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cff_memcmp_64 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a sequence of bytes from two adress have the same value 64 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of sequence to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if are equals and 0 if not. </dd></dl>

</div>
</div>
<a id="ga218e303b8bc16cb29424a87793eac95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218e303b8bc16cb29424a87793eac95c">&#9670;&nbsp;</a></span>cff_memcmp_8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cff_memcmp_8 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a sequence of bytes from two adress have the same value 8 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of sequence to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if are equals and 0 if not. </dd></dl>

</div>
</div>
<a id="ga6e3a3426c9610dfd1397d12838560f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e3a3426c9610dfd1397d12838560f07">&#9670;&nbsp;</a></span>cff_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memcpy </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence of bytes from src to dest. </p>
<p>If the dest and src buffers overlaps use the cff_memmove instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_size</td><td>lenght of bytes that will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_size</td><td>lenght of bytes of the block that will receive the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad468d324fac5c33fb8face5a53077e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad468d324fac5c33fb8face5a53077e7d">&#9670;&nbsp;</a></span>cff_memcpy_16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memcpy_16 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence of bytes from src to dest 16 bits at a time. </p>
<p>If the dest and src buffers overlaps use the cff_memmove instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes that will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaee1f881d66530582a85576f574c20b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee1f881d66530582a85576f574c20b5">&#9670;&nbsp;</a></span>cff_memcpy_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memcpy_32 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence of bytes from src to dest 32 bits at a time. </p>
<p>If the dest and src buffers overlaps use the cff_memmove instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes that will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3388ff2de7f5be41ba8f16b50fa32ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3388ff2de7f5be41ba8f16b50fa32ae7">&#9670;&nbsp;</a></span>cff_memcpy_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memcpy_64 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence of bytes from src to dest 64 bits at a time. </p>
<p>If the dest and src buffers overlaps use the cff_memmove instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes that will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1de69c3a155909468ef291bdc829dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1de69c3a155909468ef291bdc829dc6e">&#9670;&nbsp;</a></span>cff_memcpy_8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memcpy_8 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sequence of bytes from src to dest 8 bits at a time. </p>
<p>If the dest and src buffers overlaps use the cff_memmove instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes that will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6a6a44fbe82e8a94581c78788117237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a6a44fbe82e8a94581c78788117237">&#9670;&nbsp;</a></span>cff_memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memmove </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a sequence of bytes from src to dest. </p>
<p>Better option when the src and dest buffer overlaps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to the adress of the data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">des</td><td>pointer to the adress that will receive the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_size</td><td>lenght of bytes that will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_size</td><td>lenght of bytes of the block that will receive the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd76bcd3d6736ee62e1c24f020426b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd76bcd3d6736ee62e1c24f020426b26">&#9670;&nbsp;</a></span>cff_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values of an memory block to a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to be setted in every byte of the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa17df1fd696d59eef769f7bb2d33cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17df1fd696d59eef769f7bb2d33cc9a">&#9670;&nbsp;</a></span>cff_memset_16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memset_16 </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values of an memory block to a value 16 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to be setted in every byte of the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf67e79f9c78ca3fc8463712522d20f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf67e79f9c78ca3fc8463712522d20f4">&#9670;&nbsp;</a></span>cff_memset_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memset_32 </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values of an memory block to a value 32 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to be setted in every byte of the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab20903b42f22118605a60452eb93df5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20903b42f22118605a60452eb93df5f">&#9670;&nbsp;</a></span>cff_memset_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memset_64 </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values of an memory block to a value 64 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to be setted in every byte of the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2435b5ed5edcc3625a0ec8305c21b759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2435b5ed5edcc3625a0ec8305c21b759">&#9670;&nbsp;</a></span>cff_memset_8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_memset_8 </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values of an memory block to a value 8 bits at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to be setted in every byte of the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>lenght of bytes to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6df5a128cc2f599951fadf5c488d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6df5a128cc2f599951fadf5c488d92a">&#9670;&nbsp;</a></span>cff_set_default_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_set_default_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Memory.html#ga445f854a7fb44af7fd6911674d5aaf03">AllocatorInterface</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that provides a pointer to the default memory allocator in the process. </p>
<p>By default this function will return a pointer to an allocator interface that uses the functions provided by the libc (eg. malloc, realloc and free). The default allocator can be changed using the </p>

</div>
</div>
<a id="gab0108b146a32a216acc45e67da082452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0108b146a32a216acc45e67da082452">&#9670;&nbsp;</a></span>cff_stack_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * cff_stack_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory block on stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of block to be allocated in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory block or null in failure cases.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="ga3a061df742a844aa0bbb3487f4962705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a061df742a844aa0bbb3487f4962705">&#9670;&nbsp;</a></span>cff_stack_alloc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cff_stack_alloc_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a memory block on stack. </p>
<p>Be aware that some runtimes doesn't allow manually stack release, in such cases this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be deallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
<a id="gaf49b63a4451c349ef8f63b8a86410990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49b63a4451c349ef8f63b8a86410990">&#9670;&nbsp;</a></span>cff_stack_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cff_stack_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates a memory block on stack. </p>
<p>Internally, this function will allocate a new block on stack, copy the data from old block to the new and try to dealloc the old block, be aware that some runtimes doesn't allow manually stack release, in such cases both memory blocks will be allocated until the end of scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the block that will be reallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the new size for the memory block in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>pointer to the memory block after reallocated or to null in failure case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in failure case or 1 in sucess case.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called depends on the compiler used and target operating system. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
